#!/usr/bin/perl

## USE:
## takes an amazon valid values csv and converts it to a json file for use with amazon syndication.

## note - the config is not generated by this script. The config has previously been generated by 20110208-addconfig.pl 

## ACCEPTABLE PARAMETERS:
##	source_file = /path/filename
## destination_file = /path/filename
 
## FILE FORMATTING for amazon valid values file
##
##		(EXAMPLE CSV FILE - /httpd/static/definitions/amz/example.csv)
##
##		*****(these comments are primarily to aid in constructing the amazon valid values file to be imported) 
##
##		-	FIELD ATTRIBUTE DECLARATION
##			-	the attributes that determine the fields fucntion behavior
##			- 	should all be in the first cell of the cvs file separated by commas (ie. "type, xmlpath etc")
##			-	valid attributes:
## 
##				- 	ns -	 							the zoovy field type. ie. 'select', 'textbox' etc
##				- 	type - 							the zoovy field type. ie. 'select', 'textbox' etc
##				- 	xmlpath - 						the path used for the attribute in the xml. ie. ClothingAccessories.ClassificationData.ID
##				- 	amz_attrib -					the amazon attribute name to be used in the xml
##				- 	amz-format - 					the format determines how the attribute will be validated. ie Text.
##				- 	Title - 							the attribute title dispalyed in the zoovy ui
##				- 	mandatory -						determines whether this is a mandatroy field
##				- 	amz-max-length - 				max allowed length of value 
##				- 	amz-min-length - 				min allowed length of value
##				- 	id -								zoovy attribute
##				- 	max-allowed-lines - 			max allowed lines (only applies to text lists)
##				- 	aum -								allowed units of measure for attirubute saparated by a comma (ie. CM,IN)
##				- 	amazon-allow-blank -			specifies if a value can be blank (currently only used for the files hidden attribute)
##
##				variation specific attributes
##				-	vkey - Variation keyword of the field (ie Size) 
##				-	variation-type - determines thpe of variation attribute it is (ie Parentage)
##
##				hidden field specific attributes (added by brian. i'm not sure they do anything but since they were added by brian i left them in place) 
##				-	PROMPT - see example.csv 
##				-	DATA - see example.csv
##
##		- 	FIELD NAMES
##			-	the 2nd line in the file should always contain the field names (amazon flat file field names - not necessarily the same as the xsd value 
##				or Zoovy equivalunt attribute. (ie Shoe-Closure-Type)
##			-	the field names will be listed left to right,  each field on a new column 
##			-  the data is used for sorting later in the code and for references purposes only
##				- 	it is currently not saved in the json - we may save in the json in the future
##
##		-	FIELD ATTRIBUTE VALUES
##			-	the rows directly after the the attribute declaration line. They should 
##			-	these are the values corresponding to the attribute tpe(ie if the row is for 'type' the row will consist of values like 'select' or 'textbox')
##			-	there should be 1 row for every field attribute used (ie type values might be on row 2 and xmlpath values on row 3)
##			-	it is not necessary for to have a value for every field. you may add a value in one column and leave the others black if the field doesnt need
##				that attribute.    
##
##		-	VALID VALUES
##			-	amazon usually gives a lists of allowed values for a specific field.
##			-	when they do we create a select list for the field which the merchants saved value is validated against.
##			-	valid values take up all rows after the field attribute rows.  




use strict;
use lib "/httpd/modules";
use Data::Dumper;
use JSON::XS;
use File::Slurp;
use Text::CSV_XS;
use IO::Scalar;
require Text::CSV;

my $ERROR = '';
my %params = ();
foreach my $arg (@ARGV) {
	if ($arg !~ /=/) { $ERROR = "parameters and values must be separated  by ="; }
	my ($k,$v) = split(/=/,$arg);
	$params{$k} = $v;
	}

my $source_file = '';
my $destination_file = '';

if ((not defined $params{'source_file'}) || (not defined $params{'destination_file'})) {
	$ERROR = "source_file and destination_file are required parameters";
	}
else {
	$source_file = $params{'source_file'};
	$destination_file = $params{'destination_file'};
	}

my @rows = ();
## parse data from amazon valid values file

my $csv = Text::CSV_XS->new ({ binary => 1 });
open (CSV, "<", $source_file) or die $!;

while (<CSV>) {
	my $status = $csv->parse($_);
	my @columns = $csv->fields();
	push @rows, [@columns];
	}


my $attrib_row = shift @rows;   
## a reference of field attributes to be used - only the column contains data 
my $attributes = shift @$attrib_row;
my @attribs = split (/,/, $attributes); #@attribs is now an array of all field attribute names (ie (id,aum)

## a reference of field names
my $field_ref = shift @rows;

## %FIELD_ATTRIB_DATA is a hash of all field attribute values
##		- 	each column number corresponds to the same element number in @attribs. (ie if element 0 in @attribs is type, column 0 of FIELD_ATTRIB_VALUES contains
##			all of the type data for every field)	  
my %FIELD_ATTRIB_DATA = ();

foreach my $attrib(@attribs) {
	my $row = shift @rows;
	$FIELD_ATTRIB_DATA{$attrib} = $row;
	}



## everything left in @rows should be valid values
my @valid_values = @rows;

close CSV;

## take a column count to ensure the correct field attribute data is matched with the correct field
my $element_count = 0;

my $combined_field_data = [];
foreach my $field (@$field_ref) {
	my $field_data = ();
	
	
	if (lc($FIELD_ATTRIB_DATA{'type'}[$element_count]) eq 'select') {
		## fields with a type of 'select' should always have valid values so we need to make a select list containing the values.
		##		-	these are called options in the json
		my $options = [];
		push @{$options}, {T => "", V => ""};

		foreach my $value (@valid_values){
			# @valid_values contains rows of valid values so we need to pull the relevant value to this field from each row of valid values
			if ($value->[$element_count] ne '') {
				push @{$options}, {p => $value->[$element_count], v => $value->[$element_count]};   
				}	
			}
		$field_data->{'options'} = $options;
		}
	foreach my $attrib (@attribs) {
		if ($FIELD_ATTRIB_DATA{$attrib}[$element_count] ne '') {
#			print "$attrib value is $FIELD_ATTRIB_DATA{$attrib}[$element_count]\n";
			## if the field attribute does not have a corresponding value don't add to $field_data
			if ($attrib eq 'amz-format') {
				$FIELD_ATTRIB_DATA{$attrib}[$element_count] = ucfirst($FIELD_ATTRIB_DATA{$attrib}[$element_count]);
				## amz_format should always be formatted with an uc first letter.
				}
			elsif ($attrib eq 'type') {
				$FIELD_ATTRIB_DATA{$attrib}[$element_count] = lc($FIELD_ATTRIB_DATA{$attrib}[$element_count]);
				## type should always be formatted entirely in lower case.
				}
			$field_data->{$attrib} = $FIELD_ATTRIB_DATA{$attrib}[$element_count];
#			print Dumper($field_data);
			}
		}
	
	push @$combined_field_data, $field_data;
	$element_count ++;
	}

# Convert data to a json format and copy to file.
my $coder = JSON::XS->new->ascii->pretty->allow_nonref;
my $pretty_printed_unencoded = $coder->encode ($combined_field_data);
open F, ">$destination_file";
print F $pretty_printed_unencoded;
close F;


print $pretty_printed_unencoded;

exit;